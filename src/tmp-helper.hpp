#include <type_traits>

namespace zsr {

/**
 * Traits for checking if a type is zserio generated.
 *
 * Note: Specializations are generated by
 *       zserio cpp_reflect generator macros.
 */
template <class _T>
struct IsCompound : std::false_type {};

template <class _T>
struct Type2Compound;

template <class _T>
void check_isa(const zsr::Introspectable& i) noexcept(false)
{
    if (zsr::Type2Compound<_T>::ptr != i.meta && i.meta)
        throw zsr::IntrospectableCastError{};
}

template <class _Compound>
_Compound& introspectable_cast(zsr::Introspectable& i) {
    check_isa<_Compound>(i);
    return *i.obj->as<_Compound>().obj;
}

template <class _Compound>
const _Compound& introspectable_cast(const zsr::Introspectable& i) {
    check_isa<_Compound>(i);
    return *i.obj->as<_Compound>().obj;
}

template <class _Compound>
std::shared_ptr<_Compound> shared_introspectable_cast(const zsr::Introspectable& i) {
    check_isa<_Compound>(i);
    return i.obj->as<_Compound>().obj;
}

/**
 * Remove std::vector container from type
 */
template <class _Type>
struct RemoveVector {
    using Type = _Type;
};

template <class _Type>
struct RemoveVector<std::vector<_Type>> {
    using Type = _Type;
};

template <class _Type>
using RemoveVectorT = typename RemoveVector<_Type>::Type;

/**
 * Trait for getting type information about member functions.
 */
template <class _Function>
struct MemberFunctionTraits;

template <class _Result, class _Class, class... _Args>
struct MemberFunctionTraits<_Result(_Class::*)(_Args...)> {
    using ClassType = _Class;
    using ReturnType = _Result;
    using ArgumentTupleType = std::tuple<std::decay_t<_Args>...>;
};

template <class _Function>
using argument_tuple_t =
    typename MemberFunctionTraits<_Function>::ArgumentTupleType;

/**
 * Function for building a zsr::CType instance for a given C type.
 */
template <class _Type, class _Enable = void>
struct CTypeTraits;

template <class _Type>
struct CTypeTraits<std::vector<_Type>> {
    static auto set(CType& type) {
        CTypeTraits<_Type>::set(type);
        type.array = true;
    }
};

template <>
struct CTypeTraits<bool> {
    static auto set(CType& type) {
        type.type = CType::Bool;
        type.size = 1u;
        type.array = false;
    }
};

template <class _Type>
struct CTypeTraits<_Type, std::enable_if_t<std::is_unsigned<_Type>::value>> {
    static auto set(CType& type) {
        type.type = CType::UInt;
        type.size = sizeof(_Type);
        type.array = false;
    }
};

template <class _Type>
struct CTypeTraits<_Type, std::enable_if_t<std::is_signed<_Type>::value &&
                                           !std::is_floating_point<_Type>::value>> {
    static auto set(CType& type) {
        type.type = CType::Int;
        type.size = sizeof(_Type);
        type.array = false;
    }
};

template <class _Type>
struct CTypeTraits<_Type, std::enable_if_t<std::is_floating_point<_Type>::value>> {
    static auto set(CType& type) {
        type.type = CType::Float;
        type.size = sizeof(_Type);
        type.array = false;
    }
};

template <class _Type>
struct CTypeTraits<_Type, std::enable_if_t<std::is_enum<_Type>::value>> {
    static auto set(CType& type) {
        type.type = CType::Enum;
        type.size = sizeof(std::underlying_type_t<_Type>);
        type.array = false;
    }
};

template <>
struct CTypeTraits<std::string> {
    static auto set(CType& type) {
        type.type = CType::String;
        type.size = 0u;
        type.array = false;
    }
};

template <class _Type>
struct CTypeTraits<_Type, std::enable_if_t<IsCompound<_Type>::value>> {
    static auto set(CType& type) {
        type.type = CType::Structure;
        type.size = 0u;
        type.array = false;
    }
};



/**
 * Structure field accessor generation functions
 * for fundamental (false) and zserio generated (true) types.
 */
template <bool _IsStruct>
struct GenFieldAccessorHelper;

template <>
struct GenFieldAccessorHelper<false> {
    template <class _Structure, class _MemberType, class _GetFun>
    static auto getFun(_GetFun fun)
    {
        return [fun](const zsr::Introspectable& i) -> zsr::Variant {
            const auto& obj = introspectable_cast<_Structure>(i);
            return zsr::Variant(
                fun(obj)
            );
        };
    }

    template <class _Structure, class _Value, class _SetFun>
    static auto setFun(_SetFun fun) {
        return [fun](zsr::Introspectable& i, zsr::Variant v) {
            auto& obj = introspectable_cast<_Structure>(i);
            if (auto vv = v.get<_Value>())
                fun(obj, std::move(*vv));
            else
                /* TODO: Throw */;
        };
    }
};

template <>
struct GenFieldAccessorHelper<true> {
    template <class _Structure, class _MemberType, class _GetFun>
    static auto getFun(_GetFun fun)
    {
        return [fun](const zsr::Introspectable& i) -> zsr::Variant {
            const auto& master = i.obj->as<_Structure>().obj;
            const auto& obj = introspectable_cast<_Structure>(i);

            const _MemberType* value = &fun(obj);
            return zsr::Variant(
                zsr::Introspectable(
                    Type2Compound<RemoveVectorT<_MemberType>>::ptr,
                    zsr::impl::makeWeakInstance(
                        master,
                        value
                    )
                )
            );
        };
    }

    template <class _Structure, class _Value, class _SetFun>
    static auto setFun(_SetFun fun)
    {
        return [fun](zsr::Introspectable& i, zsr::Variant v) {
            auto& obj = introspectable_cast<_Structure>(i);
            if (auto vv = v.get<zsr::Introspectable>())
                fun(obj, *vv->obj->as<_Value>().obj); /* Cast is unsafe */
            else
                /* TODO: Throw */;
        };
    }
};

}
