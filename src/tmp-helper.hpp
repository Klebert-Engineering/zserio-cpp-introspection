#include <type_traits>
#include <iostream>

namespace zsr {

/**
 * Traits for checking if a type is zserio generated.
 *
 * Note: Specializations are generated by
 *       zserio cpp_reflect generator macros.
 */
template <class _T>
struct IsCompound : std::false_type {};

template <class _T>
struct meta_for_compound;

template <class _T>
void check_isa(const zsr::Introspectable& i) noexcept(false)
{
    if (zsr::meta_for_compound<_T>::ptr != i.meta && i.meta)
        throw zsr::IntrospectableCastError{};
}

template <class _Compound>
_Compound& introspectable_cast(zsr::Introspectable& i) {
    check_isa<_Compound>(i);
    return *i.obj->as<_Compound>().obj;
}

template <class _Compound>
const _Compound& introspectable_cast(const zsr::Introspectable& i) {
    check_isa<_Compound>(i);
    return *i.obj->as<_Compound>().obj;
}

template <class _Compound>
std::shared_ptr<_Compound> shared_introspectable_cast(const zsr::Introspectable& i) {
    check_isa<_Compound>(i);
    return i.obj->as<_Compound>().obj;
}

/**
 *
 */
template <class _Type>
struct is_vector : std::false_type {};

template <class _Type>
struct is_vector<std::vector<_Type>> : std::true_type {};

/**
 * Remove std::vector container from type
 */
template <class _Type>
struct RemoveVector {
    using Type = _Type;
};

template <class _Type>
struct RemoveVector<std::vector<_Type>> {
    using Type = _Type;
};

template <class _Type>
using RemoveVectorT = typename RemoveVector<_Type>::Type;

template <class _Type>
using remove_vector_t = typename RemoveVector<_Type>::Type;

/**
 * Trait for getting type information about member functions.
 */
template <class _Function>
struct MemberFunctionTraits;

template <class _Result, class _Class, class... _Args>
struct MemberFunctionTraits<_Result(_Class::*)(_Args...)> {
    using ClassType = _Class;
    using ReturnType = _Result;
    using ArgumentTupleType = std::tuple<std::decay_t<_Args>...>;
};

template <class _Function>
using argument_tuple_t =
    typename MemberFunctionTraits<_Function>::ArgumentTupleType;

/**
 * Function for building a zsr::CType instance for a given C type.
 */
template <class _Type, class _Enable = void>
struct CTypeTraits;

template <class _Type>
struct CTypeTraits<std::vector<_Type>> {
    static auto set(CType& type) {
        CTypeTraits<_Type>::set(type);
        type.array = true;
    }
};

template <>
struct CTypeTraits<bool> {
    static auto set(CType& type) {
        type.type = CType::Bool;
        type.size = 1u;
        type.array = false;
    }
};

template <class _Type>
struct CTypeTraits<_Type, std::enable_if_t<std::is_unsigned<_Type>::value>> {
    static auto set(CType& type) {
        type.type = CType::UInt;
        type.size = sizeof(_Type);
        type.array = false;
    }
};

template <class _Type>
struct CTypeTraits<_Type, std::enable_if_t<std::is_signed<_Type>::value &&
                                           !std::is_floating_point<_Type>::value>> {
    static auto set(CType& type) {
        type.type = CType::Int;
        type.size = sizeof(_Type);
        type.array = false;
    }
};

template <class _Type>
struct CTypeTraits<_Type, std::enable_if_t<std::is_floating_point<_Type>::value>> {
    static auto set(CType& type) {
        type.type = CType::Float;
        type.size = sizeof(_Type);
        type.array = false;
    }
};

template <class _Type>
struct CTypeTraits<_Type, std::enable_if_t<std::is_enum<_Type>::value>> {
    static auto set(CType& type) {
        type.type = CType::Enum;
        type.size = sizeof(std::underlying_type_t<_Type>);
        type.array = false;
    }
};

template <>
struct CTypeTraits<std::string> {
    static auto set(CType& type) {
        type.type = CType::String;
        type.size = 0u;
        type.array = false;
    }
};

template <class _Type>
struct CTypeTraits<_Type, std::enable_if_t<IsCompound<_Type>::value>> {
    static auto set(CType& type) {
        type.type = CType::Structure;
        type.size = 0u;
        type.array = false;
    }
};



/**
 * Structure field accessor generation functions
 * for fundamental (false) and zserio generated (true) types.
 */
template <class _Type,
          bool _IsCompound = IsCompound<RemoveVectorT<_Type>>::value,
          bool _IsVector = is_vector<_Type>::value>
struct GenFieldAccessorHelper;

template <class _Type, bool _IsVector>
struct GenFieldAccessorHelper<_Type, false, _IsVector>
{
    using Type = std::decay_t<_Type>;

    template <class _Structure, class _GetFun, class _MetaType>
    static auto getFun(_GetFun fun, _MetaType*)
    {
        return [fun](const zsr::Introspectable& i) -> zsr::Variant {
            const auto& obj = introspectable_cast<_Structure>(i);
            return zsr::Variant(
                fun(obj)
            );
        };
    }

    template <class _Structure, class _SetFun, class _MetaType>
    static auto setFun(_SetFun fun, _MetaType*) {
        return [fun](zsr::Introspectable& i, zsr::Variant v) {
            auto& obj = introspectable_cast<_Structure>(i);
            if (auto vv = v.get<Type>())
                fun(obj, std::move(*vv));
            else
                /* TODO: Throw */;
        };
    }
};

template <class _Type>
struct GenFieldAccessorHelper<_Type, true /* IsCompound */, true /* IsVector */>
{
    using Type = std::decay_t<_Type>;

    template <class _Structure, class _GetFun, class _MetaType>
    static auto getFun(_GetFun fun, _MetaType* meta)
    {
        return [fun, meta](const zsr::Introspectable& i) -> zsr::Variant {
            const auto& obj = introspectable_cast<_Structure>(i);
            const auto* vector = &fun(obj);

            std::vector<Introspectable> ret;
            ret.reserve(vector->size());

            std::transform(vector->begin(), vector->end(), std::back_inserter(ret),
                           [&](const auto& item) {
                               return zsr::Introspectable(
                                   meta_for_compound<remove_vector_t<Type>>::ptr,
                                   zsr::impl::makeWeakInstance(
                                       i.obj,
                                       meta,
                                       &item
                                   )
                               );
                           });

            return zsr::Variant(std::move(ret));
        };
    }

    template <class _Structure, class _SetFun, class _MetaType>
    static auto setFun(_SetFun fun, _MetaType* meta)
    {
        return [fun, meta](zsr::Introspectable& i, zsr::Variant v) {
            auto& obj = introspectable_cast<_Structure>(i);

            if (auto vector = v.get<std::vector<Introspectable>>()) {
                i.obj->makeChildrenOwning(meta);

                std::vector<remove_vector_t<Type>> zserioVector;
                zserioVector.reserve(vector->size());

                std::transform(vector->begin(), vector->end(), std::back_inserter(zserioVector),
                               [&](const auto& item) {
                                   return *item.obj->template as<remove_vector_t<Type>>().obj;
                               });

                fun(obj, std::move(zserioVector));
            } else {
                ; /* TODO: Throw */
            }
        };
    }
};

template <class _Type>
struct GenFieldAccessorHelper<_Type, true /* IsCompound */, false /* IsVector */>
{
    using Type = std::decay_t<_Type>;
   
    template <class _Structure, class _GetFun, class _MetaType>
    static auto getFun(_GetFun fun, _MetaType* meta)
    {
        return [fun, meta](const zsr::Introspectable& i) -> zsr::Variant {
            const auto& obj = introspectable_cast<_Structure>(i);

            const auto* value = &fun(obj);
            return zsr::Variant(
                zsr::Introspectable(
                    meta_for_compound<remove_vector_t<Type>>::ptr,
                    zsr::impl::makeWeakInstance(
                        i.obj,
                        meta,
                        value
                    )
                )
            );
        };
    }

    template <class _Structure, class _SetFun, class _MetaType>
    static auto setFun(_SetFun fun, _MetaType* meta)
    {
        return [fun, meta](zsr::Introspectable& i, zsr::Variant v) {
            auto& obj = introspectable_cast<_Structure>(i);
            if (auto vv = v.get<zsr::Introspectable>()) {
                i.obj->makeChildrenOwning(meta);

                fun(obj, *vv->obj->as<Type>().obj);
            } else
                /* TODO: Throw */;
        };
    }
};

}
